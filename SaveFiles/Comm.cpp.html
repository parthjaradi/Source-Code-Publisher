<!DOCTYPE HTML>
<html>
  <head>
    <Title>Comm.cpp</Title>
    <style>
     .comments {
     color: green }
      h3 {
        font-family: Cambria,Consolas;text-align: center;color: #f4602e;
      }
      h4 {
        font-family: Cambria,Consolas;
      }
      body {
        padding:0px 10px;
        font-family: Cambria,Consolas;
        font-size: 0.9375em;
        font-weight: normal;
      }
      .commentsBtn,.classBtn,.functionBtn {
      background-image: linear-gradient(to right, rgba(208, 212, 219,0), rgba(208, 212, 219,0.35));
      border: none;
      color: white;
      padding: 15px 32px;
      text - align: center;
      text - decoration: none;
      display: inline - block;
      margin: 4px 2px;
      cursor: pointer;
      }
      </style>
  <script src="myscripts.js"></script> 
  </head>

  <body>    <h3>Source Code File : Comm.cpp<br/> </h3>
    <h4> Dependencies:       <a href="Cpp11-BlockingQueue.h.html">Cpp11-BlockingQueue.h</a>
      <a href="Logger.h.html">Logger.h</a>
      <a href="Utilities.h.html">Utilities.h</a>
      <a href="Comm.h.html">Comm.h</a>
    </h4><input type = "button" id = "commentsBtn" onclick = toggleComments() value = "Hide Comments"><input type = "button" id = "functionBtn" onclick = toggleFunctions() value = "Hide Functions"><input type = "button" id = "classBtn" onclick = toggleClasses() value = "Hide Classes">    <pre>
<div class = "comments">////////////////////////////////////////////////////////////////////</div><div class = "comments">/ Comm.h - message-passing communication facility                 //</div><div class = "comments">/ ver 2.0                                                         //</div><div class = "comments">/ Jim Fawcett, CSE687-OnLine Object Oriented Design, Fall 2017    //</div><div class = "comments">////////////////////////////////////////////////////////////////////</div>
#include "Comm.h"
#include "../Logger/Logger.h"
#include "../Utilities/Utilities.h"
#include "../Cpp11-BlockingQueue/Cpp11-BlockingQueue.h"
#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;
#include &lt;conio.h&gt;

using namespace MsgPassingCommunication;
using namespace Sockets;
using SUtils = Utilities::StringHelper;

const std::string saveFilePath = "../SaveFiles";
const std::string sendFilePath = "../SendFiles";
const size_t BlockSize = 1024;
Socket::byte rwBuffer[BlockSize];

<div class = "comments">/----&lt; constructor sets port &gt;--------------------------------------</div>
Receiver::Receiver(EndPoint ep, const std::string& name) : listener(ep.port), rcvrName(name)
<div class=function id=29>{
  StaticLogger&lt;1&gt;::write("\n  -- starting Receiver");
}</div>
<div class = "comments">/----&lt; returns reference to receive queue &gt;-------------------------</div>
BlockingQueue&lt;Message&gt;* Receiver::queue()
<div class=function id=35>{
  return &rcvQ;
}</div>
<div class = "comments">/----&lt; starts listener thread running callable object &gt;-------------</div>
template&lt;typename CallableObject&gt;
void Receiver::start(CallableObject& co)
<div class=function id=42>{
  listener.start(co);
}</div>
<div class = "comments">/----&lt; stops listener thread &gt;--------------------------------------</div>
void Receiver::stop()
<div class=function id=48>{
  listener.stop();
}</div>
<div class = "comments">/----&lt; retrieves received message &gt;---------------------------------</div>
Message Receiver::getMessage()
<div class=function id=54>{
  StaticLogger&lt;1&gt;::write("\n  -- " + rcvrName + " deQing message");
  return rcvQ.deQ();
}</div>
<div class = "comments">/----&lt; constructor initializes endpoint object &gt;--------------------</div>
Sender::Sender(const std::string& name) : sndrName(name)
<div class=function id=61>{
  lastEP = EndPoint();  <div class = "comments">/ used to detect change in destination</div>}</div>
<div class = "comments">/----&lt; destructor waits for send thread to terminate &gt;--------------</div>
Sender::~Sender()
<div class=function id=67>{
  if (sendThread.joinable())
    sendThread.join();
}</div>
<div class = "comments">/----&lt; starts send thread deQ, inspect, and send loop &gt;-------------</div>
void Sender::start()
<div class=function id=74>{
  std::function &lt;void()&gt; threadProc = [&]() <div class=cclass id=75>{
    while (true)
    <div class=function id=77>{
      Message msg = sndQ.deQ();

      if (msg.command() == "quit")
      <div class=control id=81>{
        StaticLogger&lt;1&gt;::write("\n  -- send thread shutting down");
        return;
      }</div>
      StaticLogger&lt;1&gt;::write("\n  -- " + sndrName + " send thread sending " + msg.name());
      std::string msgStr = msg.toString();

      if (msg.to().address != lastEP.address || msg.to().port != lastEP.port)
      <div class=control id=89>{
        connecter.shutDown();
        <div class = "comments">/connecter.close();</div>        StaticLogger&lt;1&gt;::write("\n  -- attempting to connect to new endpoint: " + msg.to().toString());
        if (!connect(msg.to()))
        <div class=function id=94>{
          StaticLogger&lt;1&gt;::write("\n can't connect");
          continue;
        }</div>
        else
        <div class=function id=99>{
          StaticLogger&lt;1&gt;::write("\n  connected to " + msg.to().toString());
        }</div>
      }</div>
      if (msg.containsKey("file"))
      <div class=control id=104>{
        sendFile(msg);
      }</div>
      else
      <div class=control id=108>{
        bool sendRslt = connecter.send(msgStr.length(), (Socket::byte*)msgStr.c_str());
      }</div>
    }</div>
  };</div>
  std::thread t(threadProc);
  sendThread = std::move(t);
}</div>
<div class = "comments">/----&lt; stops send thread by posting quit message &gt;------------------</div>
void Sender::stop()
<div class=function id=119>{
  Message msg;
  msg.name("quit");
  msg.command("quit");
  postMessage(msg);
  connecter.shutDown();
}</div>
<div class = "comments">/----&lt; attempts to connect to endpoint ep &gt;-------------------------</div>
bool Sender::connect(EndPoint ep)
<div class=function id=129>{
  lastEP = ep;
  return connecter.connect(ep.address, ep.port);
}</div>
<div class = "comments">/----&lt; posts message to send queue &gt;--------------------------------</div>
void Sender::postMessage(Message msg)
<div class=function id=136>{
  sndQ.enQ(msg);
}</div>
<div class = "comments">/----&lt; sends binary file &gt;------------------------------------------</div><div class = "comments">*
*  - not implemented yet
*/</div>
bool Sender::sendFile(Message msg)
<div class=function id=144>{
  if (!msg.containsKey("file"))
    return false;
  std::string fileSpec = sendFilePath + "/" + msg.file();
  std::ifstream sendFile(fileSpec, std::ios::binary);
  if (!sendFile.good())
    return false;
  while (true)
  <div class=control id=152>{
    sendFile.read(rwBuffer, BlockSize);
    size_t blockSize = (size_t)sendFile.gcount();
    msg.contentLength(blockSize);
    std::string msgString = msg.toString();
    connecter.sendString(msgString);
    if (blockSize == 0)
      break;
    connecter.send(blockSize, rwBuffer);
  }</div>
  sendFile.close();
  return true;
}</div>
<div class = "comments">/----&lt; callable object posts incoming message to rcvQ &gt;-------------</div><div class = "comments">*
*  This is ClientHandler for receiving messages and posting
*  to the receive queue.
*/</div>
class ClientHandler
<div class=cclass id=171>{
public:
  <div class = "comments">/----&lt; acquire reference to shared rcvQ &gt;-------------------------</div>
  ClientHandler(BlockingQueue&lt;Message&gt;* pQ, const std::string& name = "clientHandler") : pQ_(pQ), clientHandlerName(name)
  <div class=function id=176>{
    StaticLogger&lt;1&gt;::write("\n  -- starting ClientHandler");
  }</div>
  <div class = "comments">/----&lt; shutdown message &gt;-----------------------------------------</div>
  ~ClientHandler() 
  <div class=function id=182>{ 
    StaticLogger&lt;1&gt;::write("\n  -- ClientHandler destroyed;"); 
  }</div>
  <div class = "comments">/----&lt; set BlockingQueue &gt;----------------------------------------</div>
  void setQueue(BlockingQueue&lt;Message&gt;* pQ)
  <div class=function id=188>{
    pQ_ = pQ;
  }</div>
  <div class = "comments">/----&lt; frame message string by reading bytes from socket &gt;--------</div>
  std::string readMsg(Socket& socket)
  <div class=function id=194>{
    std::string temp, msgString;
    while (socket.validState())
    <div class=control id=197>{
      temp = socket.recvString('\n');  <div class = "comments">/ read attribute</div>      msgString += temp;
      if (temp.length() &lt; 2)           <div class = "comments">/ if empty line we are done</div>        break;
    }</div>
    return msgString;
  }</div>
  <div class = "comments">/----&lt; receive file blocks &gt;--------------------------------------</div>  <div class = "comments">*
  *  - expects msg to contain file and contentLength attributes
  *  - expects to be connected to appropriate destination
  *  - these requirements are established in Sender::start()
  */</div>
  bool receiveFile(Message msg)
  <div class=function id=212>{
    std::string fileName = msg.file();
    std::string fileSpec = saveFilePath + "/" + fileName;
    std::ofstream saveStream(fileSpec, std::ios::binary);
    if (!saveStream.good())
    <div class=control id=217>{
      return false;
    }</div>
    while (true)
    <div class=control id=221>{
      size_t blockSize = msg.contentLength();
      if (blockSize == 0)
        break;
      Socket::byte terminator;
      pSocket-&gt;recv(1, &terminator);
      pSocket-&gt;recv(blockSize, rwBuffer);
      saveStream.write(rwBuffer, blockSize);
      std::string msgString = readMsg(*pSocket);
      if (msgString.length() == 0)
      <div class=control id=231>{
        break;
      }</div>
      msg = Message::fromString(msgString);
      if (msg.contentLength() == 0)
        break;
    }</div>
    saveStream.flush();
    saveStream.close();
    pQ_-&gt;enQ(msg);
    return true;
  }</div>
  <div class = "comments">/----&lt; reads messages from socket and enQs in rcvQ &gt;--------------</div>
  void operator()(Socket socket)
  <div class=function id=246>{
    pSocket = &socket;
    while (socket.validState())
    <div class=control id=249>{
      std::string msgString = readMsg(socket);
      if (msgString.length() == 0)
      <div class=control id=252>{
        <div class = "comments">/ invalid message</div>        break;
      }</div>
      Message msg = Message::fromString(msgString);
      StaticLogger&lt;1&gt;::write("\n  -- " + clientHandlerName + " RecvThread read message: " + msg.name());
      <div class = "comments">/std::cout &lt;&lt; "\n  -- " + clientHandlerName + " RecvThread read message: " + msg.name();</div>      if (msg.containsKey("file"))
      <div class=control id=260>{
        receiveFile(msg);
      }</div>
      pQ_-&gt;enQ(msg);
      <div class = "comments">/std::cout &lt;&lt; "\n  -- message enqueued in rcvQ";</div>      if (msg.command() == "quit")
        break;
    }</div>
    StaticLogger&lt;1&gt;::write("\n  -- terminating ClientHandler thread");
  }</div>
private:
  BlockingQueue&lt;Message&gt;* pQ_;
  std::string clientHandlerName;
  Socket* pSocket = nullptr;
};
</div>
Comm::Comm(EndPoint ep, const std::string& name) : rcvr(ep, name), sndr(name), commName(name) <div class=function id=276>{}</div>

void Comm::start()
<div class=function id=279>{
  BlockingQueue&lt;Message&gt;* pQ = rcvr.queue();
  ClientHandler* pCh = new ClientHandler(pQ, commName);
  <div class = "comments">*
    There is a trivial memory leak here.  
    This ClientHandler is a prototype used to make ClientHandler copies for each connection.
    Those are not created on the heap, and are destroyed when the connection closes.
    Only one Client handler prototype is created for each Comm object and will live until
    the end of the program.

    I will clean this up in the next version.
  */</div>
  rcvr.start(*pCh);
  sndr.start();
}</div>

void Comm::stop()
<div class=function id=296>{
  rcvr.stop();
  sndr.stop();
}</div>

void Comm::postMessage(Message msg)
<div class=function id=302>{
  sndr.postMessage(msg);
}</div>

Message Comm::getMessage()
<div class=function id=307>{
  return rcvr.getMessage();
}</div>

std::string Comm::name()
<div class=function id=312>{
  return commName;
}</div>

<div class = "comments">/----&lt; test stub &gt;--------------------------------------------------</div>
#ifdef TEST_COMM

<div class = "comments">////////////////////////////////////////////////////////////////////</div><div class = "comments">/ Test #1 - Demonstrates Sender and Receiver operations</div>
void DemoSndrRcvr(const std::string& machineName)
<div class=function id=324>{
  SUtils::title("Demonstrating Sender and Receiver classes");

  SocketSystem ss;
  EndPoint ep1;
  ep1.port = 9091;
  ep1.address = "localhost";
  Receiver rcvr1(ep1);
  BlockingQueue&lt;Message&gt;* pQ1 = rcvr1.queue();

  ClientHandler ch1(pQ1);
  rcvr1.start(ch1);

  EndPoint ep2;
  ep2.port = 9092;
  ep2.address = "localhost";
  Receiver rcvr2(ep2);
  BlockingQueue&lt;Message&gt;* pQ2 = rcvr2.queue();

  ClientHandler ch2(pQ2);
  rcvr2.start(ch2);

  Sender sndr;
  sndr.start();
  bool connected = sndr.connect(ep1);
  Message msg;
  msg.name("msg #1");
  msg.to(ep1);
  msg.from(msg.to());
  msg.command("do it");
  msg.attribute("bodyAttrib", "zzz");
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  sndr.postMessage(msg);

  msg.name("msg #2");
  msg.to(EndPoint(machineName, 9092));
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  sndr.postMessage(msg);

  Message rcvdMsg = rcvr1.getMessage();  <div class = "comments">/ blocks until message arrives</div>  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  rcvr1 in main received message: " &lt;&lt; rcvdMsg.name();
  rcvdMsg.show();

  rcvdMsg = rcvr2.getMessage();  <div class = "comments">/ blocks until message arrives</div>  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  rcvr2 in main received message: " &lt;&lt; rcvdMsg.name();
  rcvdMsg.show();

  SUtils::title("Sending message to EndPoint that doesn't exist");

  msg.name("msg #3");
  msg.to(EndPoint("DoesNotExist", 1111));  <div class = "comments">/ Unknown endpoint - should fail</div>  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  msg.show();
  sndr.postMessage(msg);                   <div class = "comments">/ will never reach rcvr</div>
  msg.name("msg #4");
  msg.to(EndPoint("localhost", 9091));
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  sndr in main posting message:  " &lt;&lt; msg.name();
  sndr.postMessage(msg);                  <div class = "comments">/ this should succeed</div>  StaticLogger&lt;1&gt;::flush();
  rcvdMsg = rcvr1.getMessage();
  std::cout &lt;&lt; "\n  rcvr1 in main received message: " &lt;&lt; rcvdMsg.name();
  rcvdMsg.show();

  rcvr1.stop();
  rcvr2.stop();
  sndr.stop();
  StaticLogger&lt;1&gt;::flush();

  std::cout &lt;&lt; "\n  press enter to quit DemoSndrRcvr";
  _getche();
  std::cout &lt;&lt; "\n";
}</div>

<div class = "comments">////////////////////////////////////////////////////////////////////</div><div class = "comments">/ Test #2 - Demonstrates Comm class using a single thread</div><div class = "comments">/           sending and receiving messages from two Comm</div><div class = "comments">/           instances.</div>
void DemoCommClass(const std::string& machineName)
<div class=function id=410>{
  SUtils::title("Demonstrating Comm class");

  SocketSystem ss;

  EndPoint ep1("localhost", 9191);
  Comm comm1(ep1, "comm1");
  comm1.start();

  EndPoint ep2("localhost", 9192);
  Comm comm2(ep2, "comm2");
  comm2.start();

  <div class = "comments">/ send msg from comm1 to comm1</div>  Message msg;
  msg.name("msg #1");
  msg.to(ep1);
  msg.from(ep1);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main posting message:   " &lt;&lt; msg.name();
  comm1.postMessage(msg);
  msg = comm1.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main received message:  " &lt;&lt; msg.name();
  msg.show();

  <div class = "comments">/ send msg from comm1 to comm2</div>  msg.name("msg #2");
  msg.from(ep1);
  msg.to(ep2);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main posting message:  " &lt;&lt; msg.name();
  comm1.postMessage(msg);
  msg = comm2.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main received message: " &lt;&lt; msg.name();
  msg.show();

  <div class = "comments">/ send msg from comm2 to comm1</div>  msg.name("msg #3");
  msg.to(ep1);
  msg.from(ep2);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main posting message:  " &lt;&lt; msg.name();
  comm2.postMessage(msg);
  msg = comm1.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm1 in main received message: " &lt;&lt; msg.name();
  msg.show();

  <div class = "comments">/ send msg from comm2 to comm2</div>  msg.name("msg #4");
  msg.from(ep2);
  msg.to(ep2);
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main posting message:  " &lt;&lt; msg.name();
  comm2.postMessage(msg);
  msg = comm2.getMessage();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  comm2 in main received message: " &lt;&lt; msg.name();
  msg.show();

  comm1.stop();
  comm2.stop();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  press enter to quit DemoComm";
  _getche();
}</div>
<div class = "comments">////////////////////////////////////////////////////////////////////</div><div class = "comments">/ Test #3 - Demonstrate server with two concurrent clients</div><div class = "comments">/           sending and receiving messages</div>
<div class = "comments">/----&lt; handler for first concurrent client &gt;------------------------</div>
void ThreadProcClnt1()
<div class=function id=485>{
  Comm comm(EndPoint("localhost", 9891), "client1Comm");
  comm.start();
  EndPoint serverEP("localhost", 9890);
  EndPoint clientEP("localhost", 9891);
  size_t IMax = 3;
  for (size_t i = 0; i &lt; IMax; ++i)
  <div class=anonymous id=492>{
    Message msg(serverEP, clientEP);
    msg.name("client #1 : msg #" + Utilities::Converter&lt;size_t&gt;::toString(i));
    std::cout &lt;&lt; "\n  " + comm.name() + " posting:  " &lt;&lt; msg.name();
    comm.postMessage(msg);
    Message rply = comm.getMessage();
    std::cout &lt;&lt; "\n  " + comm.name() + " received: " &lt;&lt; rply.name();
    ::Sleep(100);
  }</div>
  Message fileMsg(serverEP, clientEP);
  fileMsg.name("fileSender");
  fileMsg.file("logger.cpp");
  comm.postMessage(fileMsg);
  ::Sleep(200);

  Message stop;
  stop.name("stop");
  stop.to(serverEP);
  stop.command("stop");
  comm.postMessage(stop);
}</div>
<div class = "comments">/----&lt; handler for 2nd concurrent client &gt;--------------------------</div>
void ThreadProcClnt2()
<div class=function id=516>{
  Comm comm(EndPoint("localhost", 9892), "client2Comm");
  comm.start();
  EndPoint serverEP("localhost", 9890);
  EndPoint clientEP("localhost", 9892);
  size_t IMax = 3;
  for (size_t i = 0; i &lt; IMax; ++i)
  <div class=anonymous id=523>{
    Message msg(serverEP, clientEP);
    msg.name("client #2 : msg #" + Utilities::Converter&lt;size_t&gt;::toString(i));
    std::cout &lt;&lt; "\n  " + comm.name() + " posting:  " &lt;&lt; msg.name();
    comm.postMessage(msg);
    Message rply = comm.getMessage();
    std::cout &lt;&lt; "\n  " + comm.name() + " received: " &lt;&lt; rply.name();
  }</div>
  Message fileMsg(serverEP, clientEP);
  fileMsg.name("fileSender");
  fileMsg.file("logger.h");
  comm.postMessage(fileMsg);
  ::Sleep(200);
}</div>
<div class = "comments">/----&lt; server demonstrates two-way asynchronous communication &gt;-----</div><div class = "comments">*
*  - One server receiving messages and sending replies to
*    two concurrent clients.
*/</div>
void DemoClientServer()
<div class=function id=543>{
  SUtils::title("Demonstrating Client-Server - one server with two concurrent clients");

  SocketSystem ss;

  EndPoint serverEP("localhost", 9890);
  EndPoint clientEP("localhost", 9891);
  Comm comm(serverEP, "serverComm");
  comm.start();
  std::thread t1(ThreadProcClnt1);
  t1.detach();
  std::thread t2(ThreadProcClnt2);
  t2.detach();

  Message msg, rply;
  rply.name("reply");
  size_t count = 0;
  while (true)
  <div class=control id=561>{
    <div class = "comments">/ display each incoming message</div>
    msg = comm.getMessage();
    std::cout &lt;&lt; "\n  " + comm.name() + " received message: " &lt;&lt; msg.name();

    if (msg.containsKey("file"))  <div class = "comments">/ is this a file message?</div>    <div class=control id=568>{
      if(msg.contentLength() == 0)
        std::cout &lt;&lt; "\n  " + comm.name() + " received file \"" + msg.file() + "\" from " + msg.name();
    }</div>
    else  <div class = "comments">/ non-file message</div>    <div class=control id=573>{
      rply.to(msg.from());
      rply.from(serverEP);
      rply.name("server reply #" + Utilities::Converter&lt;size_t&gt;::toString(++count) + " to " + msg.from().toString());

      comm.postMessage(rply);
      if (msg.command() == "stop")
      <div class=control id=580>{
        break;
      }</div>
    }</div>
  }</div>

  comm.stop();
  StaticLogger&lt;1&gt;::flush();
  std::cout &lt;&lt; "\n  press enter to quit DemoClientServer";
  _getche();
}</div>

Cosmetic cosmetic;

int main()
<div class=function id=595>{
  SUtils::Title("Demo of Message-Passing Communication");
  Utilities::putline();

  StaticLogger&lt;1&gt;::attach(&std::cout);

  <div class = "comments">//////////////////////////////////////////////////////////////////</div>  <div class = "comments">/ remove comment on line below to show many of the gory details</div>  <div class = "comments">/</div>  <div class = "comments">/StaticLogger&lt;1&gt;::start();</div>
  <div class = "comments">//////////////////////////////////////////////////////////////////</div>  <div class = "comments">/ if you uncomment the lines below, you will run all demos</div>
  <div class = "comments">/DemoSndrRcvr("Odin");  // replace "Odin" with your machine name</div>  <div class = "comments">/DemoCommClass("Odin");</div>  DemoClientServer();

  return 0;
}</div>
#endif
    </pre>
  </body>
</html>
